---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chrisliu.
--- DateTime: 2019/9/25 ??6:35
---
function sysCall_init()

    robotHandle = sim.getObjectAssociatedWithScript(sim.handle_self)

    FrontLeft_MoveMotor = sim.getObjectHandle("FrontLeftMoveMotor") -- Handle of the left motor
    FrontLeft_SteerMotor = sim.getObjectHandle("FrontLeftSteerMotor") -- Handle of the left motor

    FrontRight_MoveMotor = sim.getObjectHandle("FrontRightMoveMotor") -- Handle of the left motor
    FrontRight_SteerMotor = sim.getObjectHandle("FrontRightSteerMotor") -- Handle of the left motor

    BackLeft_MoveMotor = sim.getObjectHandle("BackLeftMoveMotor") -- Handle of the left motor
    BackLeft_SteerMotor = sim.getObjectHandle("BackLeftSteerMotor") -- Handle of the left motor

    BackRight_MoveMotor = sim.getObjectHandle("BackRightMoveMotor") -- Handle of the left motor
    BackRight_SteerMotor = sim.getObjectHandle("BackRightSteerMotor") -- Handle of the left motor

    --noseSensor=sim.getObjectHandle("rosInterfaceControlledBubbleRobSensingNose") -- Handle of the proximity sensor
    -- Check if the required ROS plugin is there:
    moduleName = 0
    moduleVersion = 0
    index = 0
    pluginNotFound = true
    while moduleName do
        moduleName, moduleVersion = sim.getModuleName(index)
        if (moduleName == 'RosInterface') then
            pluginNotFound = false
        end
        index = index + 1
    end
    -- Ok now launch the ROS client application:
    if (not pluginNotFound) then
        local sysTime = sim.getSystemTimeInMs(-1)

        local All_MoveMotorTopicName = 'All_MoveMotor'
        local All_SteerMotorTopicName = 'All_SteerMotor'

        local FrontLeft_MoveMotorTopicName = 'FrontLeft_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local FrontLeft_SteerMotorTopicName = 'FrontLeft_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local FrontRight_MoveMotorTopicName = 'FrontRight_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local FrontRight_SteerMotorTopicName = 'FrontRight_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local BackLeft_MoveMotorTopicName = 'BackLeft_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local BackLeft_SteerMotorTopicName = 'BackLeft_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local BackRight_MoveMotorTopicName = 'BackRight_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local BackRight_SteerMotorTopicName = 'BackRight_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        --local sensorTopicName='sensorTrigger'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local simulationTimeTopicName = 'simTime'--..sysTime -- we add a random component so that we can have several instances of this robot running
        -- Prepare the sensor publisher and the motor speed subscribers:
        --sensorPub=simROS.advertise('/'..sensorTopicName,'std_msgs/Bool')
        simTimePub = simROS.advertise('/' .. simulationTimeTopicName, 'std_msgs/Float32')

        All_MoveMotorSub = simROS.subscribe('/' .. All_MoveMotorTopicName, 'std_msgs/Float32', 'setAll_MoveMotorVelocity_cb')
        All_SteerMotorSub = simROS.subscribe('/' .. All_SteerMotorTopicName, 'std_msgs/Float32', 'setAll_SteerMotorVelocity_cb')

        FrontLeft_MoveMotorSub = simROS.subscribe('/' .. FrontLeft_MoveMotorTopicName, 'std_msgs/Float32', 'setFrontLeft_MoveMotorVelocity_cb')
        FrontLeft_SteerMotorSub = simROS.subscribe('/' .. FrontLeft_SteerMotorTopicName, 'std_msgs/Float32', 'setFrontLeft_SteerMotorVelocity_cb')

        FrontRight_MoveMotorSub = simROS.subscribe('/' .. FrontRight_MoveMotorTopicName, 'std_msgs/Float32', 'setFrontRight_MoveMotorVelocity_cb')
        FrontRight_SteerMotorSub = simROS.subscribe('/' .. FrontRight_SteerMotorTopicName, 'std_msgs/Float32', 'setFrontRight_SteerMotorVelocity_cb')

        BackLeft_MoveMotorSub = simROS.subscribe('/' .. BackLeft_MoveMotorTopicName, 'std_msgs/Float32', 'setBackLeft_MoveMotorVelocity_cb')
        BackLeft_SteerMotorSub = simROS.subscribe('/' .. BackLeft_SteerMotorTopicName, 'std_msgs/Float32', 'setBackLeft_SteerMotorVelocity_cb')

        BackRight_MoveMotorSub = simROS.subscribe('/' .. BackRight_MoveMotorTopicName, 'std_msgs/Float32', 'setBackRight_MoveMotorVelocity_cb')
        BackRight_SteerMotorSub = simROS.subscribe('/' .. BackRight_SteerMotorTopicName, 'std_msgs/Float32', 'setBackRight_SteerMotorVelocity_cb')


        -- Now we start the client application:
        --result=sim.launchExecutable('rosBubbleRob2',leftMotorTopicName.." "..rightMotorTopicName.." "..sensorTopicName.." "..simulationTimeTopicName,0)
    else
        print("<font color='#F00'>ROS interface was not found. Cannot run.</font>@html")
    end

end

function setFrontLeft_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(FrontLeft_MoveMotor, msg.data)
end
function setFrontLeft_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(FrontLeft_SteerMotor, msg.data)
end

function setFrontRight_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(FrontRight_MoveMotor, msg.data)
end
function setFrontRight_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(FrontRight_SteerMotor, msg.data)
end

function setBackLeft_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(BackLeft_MoveMotor, msg.data)
end
function setBackLeft_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(BackLeft_SteerMotor, msg.data)
end

function setBackRight_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(BackRight_MoveMotor, msg.data)
end
function setBackRight_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(BackRight_SteerMotor, msg.data)
end

function setAll_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(FrontLeft_MoveMotor, msg.data)
    sim.setJointTargetVelocity(FrontRight_MoveMotor, msg.data)
    sim.setJointTargetVelocity(BackLeft_MoveMotor, msg.data)
    sim.setJointTargetVelocity(FrontRight_MoveMotor, msg.data)
end

function setAll_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(FrontLeft_SteerMotor, msg.data)
    sim.setJointTargetPosition(FrontRight_SteerMotor, msg.data)
    sim.setJointTargetPosition(BackLeft_SteerMotor, msg.data)
    sim.setJointTargetPosition(BackRight_SteerMotor, msg.data)
end

-- function setRightMotorVelocity_cb(msg)
--     -- Right motor speed subscriber callback
--     sim.setJointTargetVelocity(rightMotor,msg.data)
-- end

function getTransformStamped(objHandle, name, relTo, relToName)
    t = sim.getSystemTime()
    p = sim.getObjectPosition(objHandle, relTo)
    o = sim.getObjectQuaternion(objHandle, relTo)
    return {
        header = {
            stamp = t,
            frame_id = relToName
        },
        child_frame_id = name,
        transform = {
            translation = { x = p[1], y = p[2], z = p[3] },
            rotation = { x = o[1], y = o[2], z = o[3], w = o[4] }
        }
    }
end

function sysCall_actuation()
    -- Send an updated sensor and simulation time message, and send the transform of the robot:
    if not pluginNotFound then
        --         local result=sim.readProximitySensor(noseSensor)
        --         local detectionTrigger={}
        --         detectionTrigger['data']=result>0
        --         simROS.publish(sensorPub,detectionTrigger)
        simROS.publish(simTimePub, { data = sim.getSimulationTime() })
        -- Send the robot's transform:
        simROS.sendTransform(getTransformStamped(robotHandle, 'rosInterSteeringWheel', -1, 'world'))
        -- To send several transforms at once, use simROS.sendTransforms instead
    end
end

function sysCall_cleanup()
    if not pluginNotFound then
        -- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):
        --         simROS.shutdownPublisher(sensorPub)
        simROS.shutdownSubscriber(All_MoveMotorSub)
    end
end
