---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by chrisliu.
--- DateTime: 2019/9/25 ??6:35
---
function sysCall_init()

    robotHandle = sim.getObjectAssociatedWithScript(sim.handle_self)

    FrontLeft_MoveMotor = sim.getObjectHandle("W_FL") -- Handle of the left motor
    FrontLeft_SteerMotor = sim.getObjectHandle("S_FL") -- Handle of the left motor

    FrontRight_MoveMotor = sim.getObjectHandle("W_FR") -- Handle of the left motor
    FrontRight_SteerMotor = sim.getObjectHandle("S_FR") -- Handle of the left motor

    BackLeft_MoveMotor = sim.getObjectHandle("W_BL") -- Handle of the left motor
    BackLeft_SteerMotor = sim.getObjectHandle("S_BL") -- Handle of the left motor

    BackRight_MoveMotor = sim.getObjectHandle("W_BR") -- Handle of the left motor
    BackRight_SteerMotor = sim.getObjectHandle("S_BR") -- Handle of the left motor

    -- Launch the ROS client application:
    if simROS then
        local sysTime = sim.getSystemTimeInMs(-1)

        local FrontLeft_MoveMotorTopicName = 'FrontLeft_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local FrontLeft_SteerMotorTopicName = 'FrontLeft_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local FrontRight_MoveMotorTopicName = 'FrontRight_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local FrontRight_SteerMotorTopicName = 'FrontRight_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local BackLeft_MoveMotorTopicName = 'BackLeft_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local BackLeft_SteerMotorTopicName = 'BackLeft_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running

        local BackRight_MoveMotorTopicName = 'BackRight_MoveMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local BackRight_SteerMotorTopicName = 'BackRight_SteerMotor'--..sysTime -- we add a random component so that we can have several instances of this robot running
        --local sensorTopicName='sensorTrigger'--..sysTime -- we add a random component so that we can have several instances of this robot running
        local simulationTimeTopicName = 'simTime'--..sysTime -- we add a random component so that we can have several instances of this robot running
        -- Prepare the sensor publisher and the motor speed subscribers:
        --sensorPub=simROS.advertise('/'..sensorTopicName,'std_msgs/Bool')
        simTimePub = simROS.advertise('/' .. simulationTimeTopicName, 'std_msgs/Float32')

        FrontLeft_MoveMotorSub = simROS.subscribe('/' .. FrontLeft_MoveMotorTopicName, 'std_msgs/Float32', 'setFrontLeft_MoveMotorVelocity_cb')
        FrontLeft_SteerMotorSub = simROS.subscribe('/' .. FrontLeft_SteerMotorTopicName, 'std_msgs/Float32', 'setFrontLeft_SteerMotorVelocity_cb')

        FrontRight_MoveMotorSub = simROS.subscribe('/' .. FrontRight_MoveMotorTopicName, 'std_msgs/Float32', 'setFrontRight_MoveMotorVelocity_cb')
        FrontRight_SteerMotorSub = simROS.subscribe('/' .. FrontRight_SteerMotorTopicName, 'std_msgs/Float32', 'setFrontRight_SteerMotorVelocity_cb')

        BackLeft_MoveMotorSub = simROS.subscribe('/' .. BackLeft_MoveMotorTopicName, 'std_msgs/Float32', 'setBackLeft_MoveMotorVelocity_cb')
        BackLeft_SteerMotorSub = simROS.subscribe('/' .. BackLeft_SteerMotorTopicName, 'std_msgs/Float32', 'setBackLeft_SteerMotorVelocity_cb')

        BackRight_MoveMotorSub = simROS.subscribe('/' .. BackRight_MoveMotorTopicName, 'std_msgs/Float32', 'setBackRight_MoveMotorVelocity_cb')
        BackRight_SteerMotorSub = simROS.subscribe('/' .. BackRight_SteerMotorTopicName, 'std_msgs/Float32', 'setBackRight_SteerMotorVelocity_cb')

        Gyro_pub = simExtRosInterface_advertise('/imu', 'sensor_msgs/Imu')
        simExtRosInterface_publisherTreatUInt8ArrayAsString(Gyro_pub)

        Imu_data = {}

        gyroCommunicationTube = simTubeOpen(0, 'gyroData' .. simGetNameSuffix(nil), 1)
        accelCommunicationTube = simTubeOpen(0, 'accelerometerData' .. simGetNameSuffix(nil), 1)

        Body_handle = simGetObjectHandle('SteeringWheel')

        lasercommunicationTube = sim.tubeOpen(0, 'laserPointerData' .. sim.getNameSuffix(nil), 1)
        lasercommunicationTube0 = sim.tubeOpen(0, 'laserPointerData#0', 1)
        lasercommunicationTube1 = sim.tubeOpen(0, 'laserPointerData#1', 1)
        lasercommunicationTube2 = sim.tubeOpen(0, 'laserPointerData#2', 1)
        Laser_pub = simExtRosInterface_advertise('/laser', 'std_msgs/Float32MultiArray')
        simExtRosInterface_publisherTreatUInt8ArrayAsString(Laser_pub)
        Laser_data = {}
        -- Now we start the client application:
        --result=sim.launchExecutable('rosBubbleRob2',leftMotorTopicName.." "..rightMotorTopicName.." "..sensorTopicName.." "..simulationTimeTopicName,0)
    else
        print("<font color='#F00'>ROS interface was not found. Cannot run.</font>@html")
    end

end

function setFrontLeft_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(FrontLeft_MoveMotor, msg.data)
end
function setFrontLeft_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(FrontLeft_SteerMotor, msg.data)
end

function setFrontRight_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(FrontRight_MoveMotor, msg.data)
end
function setFrontRight_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(FrontRight_SteerMotor, msg.data)
end

function setBackLeft_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(BackLeft_MoveMotor, msg.data)
end
function setBackLeft_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(BackLeft_SteerMotor, msg.data)
end

function setBackRight_MoveMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetVelocity(BackRight_MoveMotor, msg.data)
end
function setBackRight_SteerMotorVelocity_cb(msg)
    -- Left motor speed subscriber callback
    sim.setJointTargetPosition(BackRight_SteerMotor, msg.data)
end

function getTransformStamped(objHandle, name, relTo, relToName)
    t = sim.getSystemTime()
    p = sim.getObjectPosition(objHandle, relTo)
    o = sim.getObjectQuaternion(objHandle, relTo)
    return {
        header = {
            stamp = t,
            frame_id = relToName
        },
        child_frame_id = name,
        transform = {
            translation = { x = p[1], y = p[2], z = p[3] },
            rotation = { x = o[1], y = o[2], z = o[3], w = o[4] }
        }
    }
end

function sysCall_actuation()
    -- Send an updated sensor and simulation time message, and send the transform of the robot:
    if not pluginNotFound then
        --         local result=sim.readProximitySensor(noseSensor)
        --         local detectionTrigger={}
        --         detectionTrigger['data']=result>0
        --         simROS.publish(sensorPub,detectionTrigger)
        simROS.publish(simTimePub, { data = sim.getSimulationTime() })
        -- Send the robot's transform:
        simROS.sendTransform(getTransformStamped(robotHandle, 'rosInterSteeringWheel', -1, 'world'))
        -- To send several transforms at once, use simROS.sendTransforms instead
    end
end

function sysCall_sensing()
    quaternion = simGetObjectQuaternion(Body_handle, -1)

    accele_data = simTubeRead(accelCommunicationTube)
    gyro_data = simTubeRead(gyroCommunicationTube)
    if (accele_data and gyro_data) then
        acceleration = simUnpackFloatTable(accele_data)
        angularVariations = simUnpackFloatTable(gyro_data)
        Imu_data['orientation'] = { x = quaternion[1], y = quaternion[2], z = quaternion[3], w = quaternion[4] }
        Imu_data['header'] = { seq = 0, stamp = simExtRosInterface_getTime(), frame_id = "sensor_frame" }
        Imu_data['linear_acceleration'] = { x = acceleration[1], y = acceleration[2], z = acceleration[3] }
        Imu_data['angular_velocity'] = { x = angularVariations[1], y = angularVariations[2], z = angularVariations[3] }

        simExtRosInterface_publish(Gyro_pub, Imu_data)
    end
    laser_data = sim.tubeRead(lasercommunicationTube)
    laser_data0 = sim.tubeRead(lasercommunicationTube0)
    laser_data1 = sim.tubeRead(lasercommunicationTube1)
    laser_data2 = sim.tubeRead(lasercommunicationTube2)
    if (laser_data) then
        distance = sim.unpackFloatTable(laser_data)[1]
        distance0 = sim.unpackFloatTable(laser_data0)[1]
        distance1 = sim.unpackFloatTable(laser_data1)[1]
        distance2 = sim.unpackFloatTable(laser_data2)[1]
        Laser_data = { data = { distance, distance0,distance1, distance2 } }

        simExtRosInterface_publish(Laser_pub, Laser_data)
    end
end

function sysCall_cleanup()
    if not pluginNotFound then
        -- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):
        simROS.shutdownPublisher(simTimePub)
        simROS.shutdownSubscriber(FrontLeft_MoveMotorSub)
        simROS.shutdownSubscriber(FrontLeft_SteerMotorSub)
        simROS.shutdownSubscriber(FrontRight_MoveMotorSub)
        simROS.shutdownSubscriber(FrontRight_SteerMotorSub)
        simROS.shutdownSubscriber(BackLeft_MoveMotorSub)
        simROS.shutdownSubscriber(BackLeft_SteerMotorSub)
        simROS.shutdownSubscriber(BackRight_MoveMotorSub)
        simROS.shutdownSubscriber(BackRight_SteerMotorSub)
        simROS.shutdownPublisher(Gyro_pub)
    end
end
